'''
Уявіть, що вам на технічному інтерв'ю дають наступну задачу, яку треба розв'язати за допомогою купи.
Є декілька мережевих кабелів різної довжини, їх потрібно об'єднати по два за раз в один кабель, використовуючи з'єднувачі, 
у порядку, який призведе до найменших витрат. Витрати на з'єднання двох кабелів дорівнюють їхній сумі довжин, а загальні витрати дорівнюють сумі з'єднання всіх кабелів.
Завдання полягає в тому, щоб знайти порядок об'єднання, який мінімізує загальні витрати.
'''

import heapq
import random
random.seed(42)


def min_cost_cable_connection(cables):
    # Створюємо купу pq з кабелями, додаємо кабелі до купи з пріоритетом, де менша довжина має більший пріоритет.
    pq = []
    for cable in cables:
        heapq.heappush(pq, (-cable, cable))

    min_cost = 0
    pairs = []

    # Витягуємо два кабелі з найвищим пріоритетом (a і b) з купи, об'єднуємо a і b в один кабель довжиною a + b, додаємо об'єднаний кабель до купи
    while len(pq) > 1:
        _, a = heapq.heappop(pq)
        _, b = heapq.heappop(pq)

        min_cost += a + b # min_cost буде сумою довжин усіх кабелів
        heapq.heappush(pq, (-a - b, a + b))

    return min_cost

# створимо набір кабелів різної довжини 20 шт від 1 до 100
cables = [random.randint(1, 100) for _ in range(20)]
print(cables)

print(min_cost_cable_connection(cables))


