# Порівняльний аналіз алгоритмів

Було проведено порівняльний аналіз алгоритмів merge_sort, insertion_sort та гібдридного Timsort в імпkементаціях вбудованих функцій Python sort та методу sorted за часом виконання шляхом їх застосування на різних наборах даних, а саме сортування на випадково згенерованих списках цілих чисел розміром 10, 100, 1000, 10000 елементів відповідного діапазону при повторенні вимірювання по 30 разів на кожен з методів для кожного набору даних і вимірюванні часу виконання засобами timeit.

### Результати порівняння наведені в таблиці нижче, таблиця раелізована черз Pandas Dataframe.

| data  	| merge_sort 	| insertion_sort 	| sorted   	| sort     	|
|-------	|------------	|----------------	|----------	|----------	|
| 10    	| 0.000357   	| 0.000120       	| 0.000012 	| 0.000006 	|
| 100   	| 0.005208   	| 0.006914       	| 0.000099 	| 0.000020 	|
| 1000  	| 0.108873   	| 1.014882       	| 0.002486 	| 0.000214 	|
| 10000 	| 1.261600   	| 110.260884     	| 0.035538 	| 0.002819 	|

Зі зведеної таблиці видно, що найбільш оптимізований алгоритм сортування є Timsort, незначно швидший в імплементації методу .sort(), що по'вязано з відсутністю необхідності створювання нового списку. Алгоритми Merge та Insertion показують на 1-2 порядки довші результати. Найгірший результат бачимо у метода Insertion, особливо на великих вибірках, де він програє Timsort на 5-6 порядків, і на 2 порядки Merge.