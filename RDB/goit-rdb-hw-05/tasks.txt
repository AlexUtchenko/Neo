1. Напишіть SQL запит, який буде відображати таблицю order_details та поле customer_id з таблиці orders 
відповідно для кожного поля запису з таблиці order_details.
Це має бути зроблено за допомогою вкладеного запиту в операторі SELECT.

SELECT 
	*, 
	(SELECT customer_id FROM orders WHERE orders.id = order_details.order_id) AS customer_id
FROM 
	order_details;


2. Напишіть SQL запит, який буде відображати таблицю order_details. 
Відфільтруйте результати так, щоб відповідний запис із таблиці orders виконував умову shipper_id=3.
Це має бути зроблено за допомогою вкладеного запиту в операторі WHERE.

SELECT *
FROM order_details
WHERE order_id IN (
    SELECT id 
    FROM orders 
    WHERE shipper_id = 3
);

Тут у внутрішньому запиті отримаємо список замовлень у яких перевізник = 3 і далі основний запит порівняє на відповідність.
На скріні 2 бачимо, що кількість повернутих рядків зменшилась до 181 з 518.


3. Напишіть SQL запит, вкладений в операторі FROM, який буде обирати рядки з умовою quantity>10 з таблиці order_details. 
Для отриманих даних знайдіть середнє значення поля quantity — групувати слід за order_id.

SELECT 
    temp_table.order_id, 
    AVG(temp_table.quantity) AS average_quantity
FROM (
    SELECT order_id, quantity 
    FROM order_details 
    WHERE quantity > 10
) AS temp_table
GROUP BY temp_table.order_id;

Тут ми, граючись з умовами в середину FROM, створюємо по факту тимчасову проміжну таблицю temp.table і далі вже працюємо з нею.


4. Розв’яжіть завдання 3, використовуючи оператор WITH для створення тимчасової таблиці temp. 
Якщо ваша версія MySQL більш рання, ніж 8.0, створіть цей запит за аналогією до того, як це зроблено в конспекті.

Тут ми явно вже робимо те, про що сказали вище, а саме: 
створюємо тимчасову таблицю 'temp' і використовуємо її для фінальних розрахунків.

WITH temp AS (
    SELECT 
        order_id, 
        quantity 
    FROM 
        order_details 
    WHERE 
        quantity > 10
)


SELECT 
    order_id, 
    AVG(quantity) AS average_quantity
FROM 
    temp
GROUP BY 
    order_id;

На скріні 4 бачимо такий самий результат як і в 3 і кількість повернутих рядків.


5. Створіть функцію з двома параметрами, яка буде ділити перший параметр на другий. 
Обидва параметри та значення, що повертається, повинні мати тип FLOAT.
Використайте конструкцію DROP FUNCTION IF EXISTS. 
Застосуйте функцію до атрибута quantity таблиці order_details. 
Другим параметром може бути довільне число на ваш розсуд.

Видаляємо функцію, якщо вона вже існує
DROP FUNCTION IF EXISTS DivideNumbers;

Змінюємо роздільник на //
DELIMITER //

Створюємо функцію згідно умов
CREATE FUNCTION DivideNumbers(val1 FLOAT, val2 FLOAT) 
RETURNS FLOAT
DETERMINISTIC -- Вказуємо, що функція завжди повертає однаковий результат для однакових вхідних даних
BEGIN
    RETURN val1 / val2;
END //

Повертаємо стандартний роздільник ;
DELIMITER ;

Застосовуємо функцію до order_details.quantity, а другим параметром взяв число 3
SELECT 
    id, 
    order_id, 
    product_id, 
    quantity, 
    DivideNumbers(quantity, 3) AS divided_quantity
FROM 
    order_details;

Видаляємо функцію
DROP FUNCTION IF EXISTS DivideNumbers;
