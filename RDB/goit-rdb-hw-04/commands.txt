1. Створіть базу даних для керування бібліотекою книг згідно зі структурою, наведеною нижче. 
Використовуйте DDL-команди для створення необхідних таблиць та їх зв'язків.

CREATE SCHEMA LibraryManagement;
USE LibraryManagement;

CREATE TABLE authors (
    author_id INT AUTO_INCREMENT PRIMARY KEY,
    author_name VARCHAR(255)
);

CREATE TABLE genres (
    genre_id INT AUTO_INCREMENT PRIMARY KEY,
    genre_name VARCHAR(255)
);

CREATE TABLE books (
    book_id INT AUTO_INCREMENT PRIMARY KEY,
    title VARCHAR(255),
    publication_year YEAR,
    author_id INT,
    genre_id INT,
    FOREIGN KEY (author_id) REFERENCES authors(author_id),
    FOREIGN KEY (genre_id) REFERENCES genres(genre_id)
);

CREATE TABLE users (
    user_id INT AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(255),
    email VARCHAR(255)
);

CREATE TABLE borrowed_books (
    borrow_id INT AUTO_INCREMENT PRIMARY KEY,
    book_id INT,
    user_id INT,
    borrow_date DATE,
    return_date DATE,
    FOREIGN KEY (book_id) REFERENCES books(book_id),
    FOREIGN KEY (user_id) REFERENCES users(user_id)
);


2. Заповніть таблиці простими видуманими тестовими даними. Достатньо одного-двох рядків у кожну таблицю.

Зберігаємо послідовність заповнення даних, щоб не порушити зв'язків

INSERT INTO authors (author_name) 
VALUES ('Джордж Орвелл'), ('Ольга Білик');

INSERT INTO genres (genre_name) 
VALUES ('Антиутопія'), ('Фентезі');

INSERT INTO users (username, email) 
VALUES ('Іван Іваненко', 'ivan.i@example.com'), 
       ('Олена Петренко', 'o.petrenko@test.com');

INSERT INTO books (title, publication_year, author_id, genre_id) 
VALUES ('1984', 1949, 1, 1), 
       ('Файна дівчина', 2005, 2, 2);

INSERT INTO borrowed_books (book_id, user_id, borrow_date, return_date) 
VALUES (1, 1, '2024-05-01', '2024-05-15'), 
       (2, 2, '2024-05-10', NULL);


3. Перейдіть до бази даних, з якою працювали у темі 3. 
Напишіть запит за допомогою операторів FROM та INNER JOIN, що об’єднує всі таблиці даних, 
які ми завантажили з файлів: order_details, orders, customers, products, categories, employees, 
shippers, suppliers. Для цього ви маєте знайти спільні ключі.
Перевірте правильність виконання запиту.

Вибираємо атрибути для вивода у фінальній таблиці і називаємо їх.
До центральної, місткової між замовленнями і когнкретними товарами приєднуємо по черзі 
решту таблиц по спільним ключам:

SELECT 
    o.id AS order_id,
    o.date AS order_date,
    c.name AS customer_name,
    e.first_name AS employee_first_name,
    e.last_name AS employee_last_name,
    sh.name AS shipper_name,
    p.name AS product_name,
    cat.name AS category_name,
    sup.name AS supplier_name,
    od.quantity,
    p.price
FROM order_details AS od
INNER JOIN orders AS o ON od.order_id = o.id
INNER JOIN customers AS c ON o.customer_id = c.id
INNER JOIN employees AS e ON o.employee_id = e.employee_id
INNER JOIN shippers AS sh ON o.shipper_id = sh.id
INNER JOIN products AS p ON od.product_id = p.id
INNER JOIN categories AS cat ON p.category_id = cat.id
INNER JOIN suppliers AS sup ON p.supplier_id = sup.id;


4. Виконайте запити, перелічені нижче.

a) Визначте, скільки рядків ви отримали (за допомогою оператора COUNT).

SELECT 
    COUNT(*) AS total_rows
FROM order_details AS od
INNER JOIN orders AS o ON od.order_id = o.id
INNER JOIN customers AS c ON o.customer_id = c.id
INNER JOIN employees AS e ON o.employee_id = e.employee_id
INNER JOIN shippers AS sh ON o.shipper_id = sh.id
INNER JOIN products AS p ON od.product_id = p.id
INNER JOIN categories AS cat ON p.category_id = cat.id
INNER JOIN suppliers AS sup ON p.supplier_id = sup.id;

b) Змініть декілька операторів INNER на LEFT чи RIGHT. Визначте, що відбувається з кількістю рядків. Чому? Напишіть відповідь у текстовому файлі.

SELECT 
    COUNT(*) AS total_rows
FROM order_details AS od
RIGHT JOIN orders AS o ON od.order_id = o.id
LEFT JOIN customers AS c ON o.customer_id = c.id
INNER JOIN employees AS e ON o.employee_id = e.employee_id
LEFT JOIN shippers AS sh ON o.shipper_id = sh.id
INNER JOIN products AS p ON od.product_id = p.id
INNER JOIN categories AS cat ON p.category_id = cat.id
INNER JOIN suppliers AS sup ON p.supplier_id = sup.id;
 
Вийшло так само - 518 записів. INNER - це перетин множин, тобто запит з ним буде завжди менше або дорівнювати кількості записів з LEFT або RIGHT, бо там до перетину маємо ще об'єднання.
Також INNER є фільтром на помилки (пусті записи), тоюто теж менше або дорівнювати, якщо база без пустих значень

c) На основі запита з пункта 3 виконайте наступне: оберіть тільки ті рядки, де employee_id > 3 та ≤ 10.

SELECT 
    o.id AS order_id,
    e.employee_id,
    e.first_name,
    e.last_name,
    c.name AS customer_name,
    p.name AS product_name,
    od.quantity
FROM order_details AS od
INNER JOIN orders AS o ON od.order_id = o.id
INNER JOIN customers AS c ON o.customer_id = c.id
INNER JOIN employees AS e ON o.employee_id = e.employee_id
INNER JOIN shippers AS sh ON o.shipper_id = sh.id
INNER JOIN products AS p ON od.product_id = p.id
INNER JOIN categories AS cat ON p.category_id = cat.id
INNER JOIN suppliers AS sup ON p.supplier_id = sup.id
WHERE e.employee_id > 3 AND e.employee_id <= 10;

d) Згрупуйте за іменем категорії, порахуйте кількість рядків у групі, середню кількість товару (кількість товару знаходиться в order_details.quantity)

SELECT 
    cat.name AS category_name,
    COUNT(*) AS total_records,
    AVG(od.quantity) AS average_quantity
FROM order_details AS od
INNER JOIN orders AS o ON od.order_id = o.id
INNER JOIN customers AS c ON o.customer_id = c.id
INNER JOIN employees AS e ON o.employee_id = e.employee_id
INNER JOIN shippers AS sh ON o.shipper_id = sh.id
INNER JOIN products AS p ON od.product_id = p.id
INNER JOIN categories AS cat ON p.category_id = cat.id
INNER JOIN suppliers AS sup ON p.supplier_id = sup.id
WHERE e.employee_id > 3 AND e.employee_id <= 10
GROUP BY cat.name;

e) Відфільтруйте рядки, де середня кількість товару більша за 21.

SELECT 
    cat.name AS category_name,
    COUNT(*) AS total_records,
    AVG(od.quantity) AS average_quantity
FROM order_details AS od
INNER JOIN orders AS o ON od.order_id = o.id
INNER JOIN customers AS c ON o.customer_id = c.id
INNER JOIN employees AS e ON o.employee_id = e.employee_id
INNER JOIN shippers AS sh ON o.shipper_id = sh.id
INNER JOIN products AS p ON od.product_id = p.id
INNER JOIN categories AS cat ON p.category_id = cat.id
INNER JOIN suppliers AS sup ON p.supplier_id = sup.id
WHERE e.employee_id > 3 AND e.employee_id <= 10
GROUP BY cat.name
HAVING AVG(od.quantity) > 21;

f) Відсортуйте рядки за спаданням кількості рядків.

SELECT 
    cat.name AS category_name,
    COUNT(*) AS total_records,
    AVG(od.quantity) AS average_quantity
FROM order_details AS od
INNER JOIN orders AS o ON od.order_id = o.id
INNER JOIN customers AS c ON o.customer_id = c.id
INNER JOIN employees AS e ON o.employee_id = e.employee_id
INNER JOIN shippers AS sh ON o.shipper_id = sh.id
INNER JOIN products AS p ON od.product_id = p.id
INNER JOIN categories AS cat ON p.category_id = cat.id
INNER JOIN suppliers AS sup ON p.supplier_id = sup.id
WHERE e.employee_id > 3 AND e.employee_id <= 10
GROUP BY cat.name
HAVING AVG(od.quantity) > 21
ORDER BY total_records DESC;

j) Виведіть на екран (оберіть) чотири рядки з пропущеним першим рядком.

SELECT 
    cat.name AS category_name,
    COUNT(*) AS total_records,
    AVG(od.quantity) AS average_quantity
FROM order_details AS od
INNER JOIN orders AS o ON od.order_id = o.id
INNER JOIN customers AS c ON o.customer_id = c.id
INNER JOIN employees AS e ON o.employee_id = e.employee_id
INNER JOIN shippers AS sh ON o.shipper_id = sh.id
INNER JOIN products AS p ON od.product_id = p.id
INNER JOIN categories AS cat ON p.category_id = cat.id
INNER JOIN suppliers AS sup ON p.supplier_id = sup.id
WHERE e.employee_id > 3 AND e.employee_id <= 10
GROUP BY cat.name
HAVING AVG(od.quantity) > 21
ORDER BY total_records DESC
LIMIT 4
OFFSET 1;
.